#!/usr/bin/env python3
"""
LaTeX Build System for Conceptual Quantum Relativity
"""

import argparse
import os
import subprocess
import sys
import time
from datetime import datetime
import logging
import yaml
from colorama import Fore, Style, init
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# Initialize colorama
init()

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format=f"{Fore.BLUE}[%(asctime)s]{Style.RESET_ALL} %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)
logger = logging.getLogger("build-system")

def load_config():
    """Load configuration from config.yaml file if it exists"""
    config_path = os.path.join(os.getcwd(), "config.yaml")
    default_config = {
        "main_file": "model.tex",
        "output_dir": "output",
        "clean_auxiliary": True,
        "bibtex_run": True,
        "makeindex_run": False,
        "latex_engine": "pdflatex",
        "latex_args": ["-interaction=nonstopmode", "-halt-on-error", "-file-line-error"],
    }
    
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r') as file:
                user_config = yaml.safe_load(file)
                if user_config:
                    default_config.update(user_config)
        except Exception as e:
            logger.error(f"Error loading config file: {e}")
    
    return default_config

def run_command(cmd, description=None):
    """Run a command and log its output"""
    if description:
        logger.info(f"{Fore.GREEN}{description}{Style.RESET_ALL}")
    
    logger.info(f"{Fore.YELLOW}Running: {' '.join(cmd)}{Style.RESET_ALL}")
    
    try:
        process = subprocess.Popen(
            cmd, 
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True
        )
        
        # Stream and log output
        for line in iter(process.stdout.readline, ''):
            if not line:
                break
            sys.stdout.write(line)
            
        # Wait for process to complete
        process.wait()
        
        if process.returncode != 0:
            logger.error(f"{Fore.RED}Command failed with code {process.returncode}{Style.RESET_ALL}")
            return False
        return True
    except Exception as e:
        logger.error(f"{Fore.RED}Error running command: {e}{Style.RESET_ALL}")
        return False

def clean_auxiliary_files(basename, output_dir):
    """Clean up auxiliary files generated by LaTeX"""
    logger.info(f"{Fore.GREEN}Cleaning auxiliary files{Style.RESET_ALL}")
    extensions = [
        '.aux', '.log', '.out', '.toc', '.lof', '.lot', '.bbl', '.blg', 
        '.fls', '.fdb_latexmk', '.synctex.gz', '.nav', '.snm', '.vrb'
    ]
    
    for ext in extensions:
        file_path = os.path.join(output_dir, f"{basename}{ext}")
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
                logger.info(f"Removed {file_path}")
            except Exception as e:
                logger.error(f"Error removing {file_path}: {e}")

def compile_latex(config, watch_mode=False):
    """Compile LaTeX document according to configuration"""
    main_file = config["main_file"]
    output_dir = config["output_dir"]
    latex_engine = config["latex_engine"]
    latex_args = config["latex_args"]
    
    # Get advanced configuration with defaults
    advanced = config.get("advanced", {})
    latex_iterations = advanced.get("latex_iterations", 2)
    synctex = advanced.get("synctex", False)
    
    # Get bibliography configuration
    bibliography = config.get("bibliography", {})
    bibtex_run = bibliography.get("bibtex_run", False)
    biblatex_run = bibliography.get("biblatex_run", False)
    biber_minimal = bibliography.get("biber_minimal", False)
    bib_file = bibliography.get("bib_file", "references/references.bib")
    makeindex_run = config.get("makeindex_run", False)
    
    # Check if references directory exists
    references_dir = os.path.dirname(bib_file)
    if not os.path.exists(references_dir):
        logger.info(f"{Fore.YELLOW}Creating references directory: {references_dir}{Style.RESET_ALL}")
        os.makedirs(references_dir, exist_ok=True)
    
    # Create output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Get basename (filename without extension)
    basename = os.path.splitext(os.path.basename(main_file))[0]
    
    # Build LaTeX command
    cmd = [latex_engine] + latex_args
    
    # Add synctex if enabled
    if synctex:
        cmd.append("-synctex=1")
    
    cmd.extend([f"-output-directory={output_dir}", main_file])
    
    # First LaTeX run - creates .aux file needed by BibTeX/Biber
    logger.info(f"{Fore.GREEN}Starting LaTeX compilation sequence{Style.RESET_ALL}")
    if not run_command(cmd, "First LaTeX run"):
        return False
    
    # Bibliography processing
    if bibtex_run:
        # Traditional BibTeX processing
        bibtex_cmd = ["bibtex", os.path.join(output_dir, basename)]
        if not run_command(bibtex_cmd, "Running BibTeX"):
            return False
    elif biblatex_run:
        # Modern BibLaTeX/Biber processing
        biber_cmd = ["biber"]
        if biber_minimal:
            biber_cmd.append("--minimal")
        biber_cmd.append(os.path.join(output_dir, basename))
        if not run_command(biber_cmd, "Running Biber"):
            return False
    
    # Run makeindex if enabled
    if makeindex_run:
        makeindex_cmd = ["makeindex", os.path.join(output_dir, f"{basename}.idx")]
        if not run_command(makeindex_cmd, "Running makeindex"):
            return False
    
    # Additional LaTeX runs to resolve references
    for i in range(latex_iterations):
        run_number = i + 2  # We already did the first run
        if not run_command(cmd, f"LaTeX run #{run_number}"):
            return False

class LatexFileHandler(FileSystemEventHandler):
    """Handle file system events for watch mode"""
    def __init__(self, config):
        self.config = config
        self.last_compiled = 0
        self.debounce_time = 3  # seconds
        
    def on_modified(self, event):
        # Check if the modified file is a .tex file
        if event.src_path.endswith('.tex') and not event.is_directory:
            current_time = time.time()
            
            # Debounce multiple events in short succession
            if current_time - self.last_compiled > self.debounce_time:
                logger.info(f"{Fore.CYAN}File change detected: {event.src_path}{Style.RESET_ALL}")
                self.last_compiled = current_time
                compile_latex(self.config, watch_mode=True)

def watch_mode(config):
    """Watch for changes and recompile on file modifications"""
    logger.info(f"{Fore.MAGENTA}Entering watch mode - press Ctrl+C to exit{Style.RESET_ALL}")
    
    # Do initial compilation
    compile_latex(config, watch_mode=True)
    
    # Set up file system observer
    event_handler = LatexFileHandler(config)
    observer = Observer()
    observer.schedule(event_handler, path=".", recursive=True)
    observer.start()
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info(f"{Fore.MAGENTA}Watch mode terminated by user{Style.RESET_ALL}")
        observer.stop()
    observer.join()

def main():
    """Main entry point for the script"""
    parser = argparse.ArgumentParser(description='Build LaTeX documents for Conceptual Quantum Relativity')
    parser.add_argument('--file', '-f', help='Main LaTeX file to compile (overrides config)')
    parser.add_argument('--output-dir', '-o', help='Output directory (overrides config)')
    parser.add_argument('--watch', '-w', action='store_true', help='Watch for changes and recompile automatically')
    parser.add_argument('--clean', '-c', action='store_true', help='Clean auxiliary files')
    parser.add_argument('--config', help='Path to custom config file')
    
    args = parser.parse_args()
    
    # Load configuration
    config = load_config()
    
    # Override config with command line arguments
    if args.file:
        config["main_file"] = args.file
    if args.output_dir:
        config["output_dir"] = args.output_dir
    if args.clean:
        config["clean_auxiliary"] = True
    
    logger.info(f"{Fore.CYAN}LaTeX Build System for Conceptual Quantum Relativity{Style.RESET_ALL}")
    logger.info(f"Working directory: {os.getcwd()}")
    logger.info(f"Compiling: {config['main_file']}")
    logger.info(f"Output directory: {config['output_dir']}")
    
    # Watch mode or single compilation
    if args.watch:
        watch_mode(config)
    else:
        compile_latex(config)

if __name__ == "__main__":
    main()